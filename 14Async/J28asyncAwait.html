<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>J28asyncAwait.html</title>
</head>
<body>
  <h2>Async / Await</h2>
  <!-- Async / Await 는 Promise 를 더욱 쉽고
  효과적으로 다루기 위한 문법적설탕 (Syntactic Sugar)이다
  복잡한 then() 절과 catch() 로 이어지는 문법 대신
  마치 동기코드를 작성하듯 비동기 작업을 순서대로 기술할 수 있다. -->
  <script>
    // 로그인 요청 : 서버로 아이디를 보내 인즐을 요청한다.
    function requestLogin(userid){
      // 요청 처리에 1초가 걸린다고 가정
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log(`${userid} 로그인 완료`);
          resolve(userid);
        }, 1000);
      });
    }
    // 회원정보조회 : 로그인 성공 후 해당 사용자의 회원정보를 조회한다.
    function getUserInfo(userid){
      return new Promise((resolve) => {
        setTimeout(() => {
          console.log(`${userid} 의 사용자 정보 조회 완료.`);
          /* 요청에 성공한 경우 객체를 반환한다.
          es6 에서는 key 와 value 가 동일하면 하나만 기술하면 된다. */
          resolve({userid, name: "성유겸"});
        }, 1000);
      });
    }
    // 화면메세지 출력 : 조회된 회원정보를 객체형식으로 받은 후 출력
    function welcomeHome(responseInfo){
      return new Promise((resolve) => {
        setTimeout(() => {
          // 객체의 key 를 통해 값을 출력한다.
          console.log(`아이디 : ${responseInfo.userid}`);
          console.log(`${responseInfo.name} 님 환영합니다`);
          resolve();
        }, 1000);
      });
    }
    // async 로 선언한 함수 내에서만 await 를 사용할 수 있다.
    async function processMain() {
      try{
        /* 각 1초씩 걸리는 요청을 순차적으로 호출한다.
        await 는 하나의 요청이 끝날때마다 대기했다가
        콜백데이터가 있으면 그 다음 작업을 진행하겠다는 의미로 사용된다.
        만약 asycn ~ await 가 없으면 응답이 오기전에
        다음 함수를 호출하므로 정상적인 결과가 출력되지 않는다. */
        const my_id = await requestLogin("gyeoms");
        const my_info = await getUserInfo(my_id);
        await welcomeHome(my_info);
        console.log("작업 완료");
      }
      catch(error){
        console.error("에러 발생",error);
      }
    }
  </script>
  <div>
    <button type="button" onclick="processMain();">로그인하기</button>
  </div>




</body>
</html>